<!-- vim: syntax=markdown -->

# Knowit 2021

## Setup

```elixir
Mix.install([
  {:httpoison, "~> 1.8"},
  {:jason, "~> 1.2"},
  {:vega_lite, "~> 0.1.2"},
  {:kino, "~> 0.3.1"},
  {:nimble_csv, "~> 1.1"},
  {:nimble_parsec, "~> 1.2.0"}
])

alias VegaLite, as: Vl
alias NimbleCSV.RFC4180, as: CSV

ExUnit.start(autorun: false)
```

```elixir
defmodule Util.Http do
  def get_text(url) do
    %{status_code: 200, body: body} = HTTPoison.get!(url, [], follow_redirect: true)
    body
  end

  def get_json(url) do
    %{status_code: 200, body: body} = HTTPoison.get!(url, [], follow_redirect: true)
    Jason.decode!(body)
  end
end
```

```elixir
defmodule Util.Counter do
  defstruct [:items]

  def new(items, default_keys \\ []) do
    defaults = default_keys |> Enum.map(fn key -> {key, 0} end) |> Enum.into(%{})

    %Util.Counter{
      items:
        items
        |> Enum.reduce(defaults, fn x, acc -> acc |> Map.update(x, 1, fn v -> v + 1 end) end)
    }
  end

  def most_common(counter, n \\ 10) do
    counter.items
    |> Map.to_list()
    |> Enum.sort(fn {_k1, val1}, {_k2, val2} -> val1 > val2 end)
    |> Enum.take(n)
  end
end

Util.Counter.new(~w/A B C B C D/, ["F"]) |> Util.Counter.most_common(15)
```

<!-- livebook:{"branch_parent_index":0} -->

## Day 1

Tall er helt klart enklest å håndtere når de er nettopp tall. Men som vi kodere vet hender det at en må forholde seg til tall som har blitt strenger. Det er jo irriterende nok, men verre blir det når tallene er gjort om til ord! I strengen "entotrefirefem" har noen gjort om 1, 2, 3, 4, 5 til ord. I denne filen har vi gjort om en liste av tall til en lang streng. Hva er summen av denne listen med tall?

### Opplysninger

* Ingen av tallene er større enn 50
* Svar med tall, ikke med ord.
* Høyeste tall blir valgt hvis man kan velge mellom to.
  * For eksempel: "femti" -> 50, altså IKKE 5 og 10

```elixir
defmodule Talltull do
  def parse(""), do: []

  def parse("ti" <> rest), do: [10] ++ parse(rest)
  def parse("tjue" <> rest), do: [20] ++ parse(rest)
  def parse("tretti" <> rest), do: [30] ++ parse(rest)
  def parse("førti" <> rest), do: [40] ++ parse(rest)
  def parse("femti" <> rest), do: [50] ++ parse(rest)
  # def parse("seksti" <> rest), do: [60] ++ parse(rest)
  # def parse("sytti" <> rest), do: [70] ++ parse(rest)
  # def parse("åtti" <> rest), do: [80] ++ parse(rest)
  # def parse("nitti" <> rest), do: [90] ++ parse(rest)

  def parse("elleve" <> rest), do: [11] ++ parse(rest)
  def parse("tolv" <> rest), do: [12] ++ parse(rest)
  def parse("tretten" <> rest), do: [13] ++ parse(rest)
  def parse("fjorten" <> rest), do: [14] ++ parse(rest)
  def parse("femten" <> rest), do: [15] ++ parse(rest)
  def parse("seksten" <> rest), do: [16] ++ parse(rest)
  def parse("sytten" <> rest), do: [17] ++ parse(rest)
  def parse("atten" <> rest), do: [18] ++ parse(rest)
  def parse("nitten" <> rest), do: [19] ++ parse(rest)

  def parse("en" <> rest), do: [1] ++ parse(rest)
  def parse("to" <> rest), do: [2] ++ parse(rest)
  def parse("tre" <> rest), do: [3] ++ parse(rest)
  def parse("fire" <> rest), do: [4] ++ parse(rest)
  def parse("fem" <> rest), do: [5] ++ parse(rest)
  def parse("seks" <> rest), do: [6] ++ parse(rest)
  def parse("sju" <> rest), do: [7] ++ parse(rest)
  def parse("åtte" <> rest), do: [8] ++ parse(rest)
  def parse("ni" <> rest), do: [9] ++ parse(rest)
end
```

```elixir
defmodule Talltull.Tests do
  use ExUnit.Case

  import Talltull

  test "entotrefirefem" do
    assert parse("entotrefirefem") |> Enum.sum() == 15
  end

  test "sjufirenitrettentrettitretrettitre" do
    assert parse("sjufirenitrettentrettitretrettitre") |> Enum.sum() == 99
  end
end

ExUnit.run()
```

```elixir
url =
  "https://julekalender-backend.knowit.no/rails/active_storage/blobs/redirect/eyJfcmFpbHMiOnsibWVzc2FnZSI6IkJBaHBNdz09IiwiZXhwIjpudWxsLCJwdXIiOiJibG9iX2lkIn19--0af4f790dec929a13e3615fdac11667323ea1597/tall.txt?disposition=inline"

day_1_input = Util.Http.get_text(url)
```

```elixir
day_1_input
|> String.trim()
|> Talltull.parse()
|> Enum.sum()
```

<!-- livebook:{"branch_parent_index":0} -->

## Day 2

I denne fila finner du en liste over alle byene som er planlagt besøkt i år. Posisjonen til byene er oppgitt på formatet Well-Known Text, mer spesifikt: Point(E, N).

Alle byene skal besøkes kun én gang. Nissefar har aldri helt klart å finne en helt optimal rute, så for å bestemme hvilken by han skal videre til, velger han alltid den nærmeste ubesøkte byen på lista.

Hvor langt kommer Nissen og reinsdyrene til å reise i år? Oppgi svaret som et heltall rundet av til nærmeste kilometer.

Anta at reisen starter og slutter nøyaktig på polpunktet og at jordens radius er 6371km.

```elixir
url =
  "https://julekalender-backend.knowit.no/rails/active_storage/blobs/redirect/eyJfcmFpbHMiOnsibWVzc2FnZSI6IkJBaHBOUT09IiwiZXhwIjpudWxsLCJwdXIiOiJibG9iX2lkIn19--7bb23c39ab7eb5b367e3b0841b86e0667756397f/cities.csv?disposition=inline"

day_2_input = Util.Http.get_text(url)
```

```elixir
defmodule Distance.GreatCircle do
  @type coords() :: {number(), number()}

  @pi_over_180 3.141592653589793 / 180.0
  @radius_of_earth_km 6_371

  @spec distance(coords(), coords()) :: float()
  def distance(%{longitude: lon1, latitude: lat1}, %{longitude: lon2, latitude: lat2}) do
    a = :math.sin((lat2 - lat1) * @pi_over_180 / 2)
    b = :math.sin((lon2 - lon1) * @pi_over_180 / 2)

    s = a * a + b * b * :math.cos(lat1 * @pi_over_180) * :math.cos(lat2 * @pi_over_180)
    2 * :math.atan2(:math.sqrt(s), :math.sqrt(1 - s)) * @radius_of_earth_km
  end
end
```

```elixir
defmodule City do
  defstruct [:name, :longitude, :latitude]

  import Distance.GreatCircle

  defp parse_point(point_str) do
    %{"x" => x, "y" => y} = Regex.named_captures(~r/Point\((?<x>.+) (?<y>.+)\)/, point_str)

    {x, ""} = Float.parse(x)
    {y, ""} = Float.parse(y)

    {x, y}
  end

  def new(name, point_str) do
    {x, y} = parse_point(point_str)
    %City{name: name, longitude: x, latitude: y}
  end

  def order_by_distance(current_city, others) do
    others
    |> Enum.sort_by(fn other_city -> distance(current_city, other_city) end)
  end

  def travel(c, []), do: [c]

  def travel(current_city, remaining_cities) do
    [next | rest] = order_by_distance(current_city, remaining_cities)
    [current_city] ++ travel(next, rest)
  end

  def distances_traveled([a, b]), do: [distance(a, b)]
  def distances_traveled([a, b | t]), do: [distance(a, b)] ++ distances_traveled([b | t])
end
```

```elixir
defmodule City.Tests do
  use ExUnit.Case

  @approx_earth_circumference 40030

  test "parse" do
    assert City.new("Salinas", "Point(-121.655555555 36.677777777)") ==
             %City{name: "Salinas", longitude: -121.655555555, latitude: 36.677777777}
  end

  test "order by haversine distance" do
    trondheim = %City{name: "Trondheim", longitude: 10.4, latitude: 63.44}
    salinas = %City{name: "Salinas", longitude: -121.655555555, latitude: 36.677777777}

    assert City.order_by_distance(
             %City{name: "Nordpolen City", longitude: 0, latitude: 90},
             [salinas, trondheim]
           ) ==
             [trondheim, salinas]
  end

  test "round trip" do
    np = %City{name: "Nordpolen City", longitude: 0, latitude: 90}
    null_island = %City{name: "Null Island", longitude: 0, latitude: 0}

    assert City.distances_traveled([np, null_island, np])
           |> Enum.sum()
           |> round == @approx_earth_circumference / 2
  end
end

ExUnit.run()
```

```elixir
cities =
  day_2_input
  |> CSV.parse_string()
  |> Enum.map(fn [name, point] -> City.new(name, point) end)

origin = %City{name: "Nordpolen City", longitude: 0, latitude: 90}
route = City.travel(origin, cities) ++ [origin]
distances = City.distances_traveled(route)

kms =
  distances
  |> Enum.sum()
  |> round
```

```elixir
Vl.new(width: 750, height: 500)
|> Vl.data_from_values(cities |> Enum.map(&Map.from_struct/1))
|> Vl.projection(type: :conic_equidistant)
|> Vl.mark(:circle)
|> Vl.encode_field(:longitude, "longitude", type: :quantitative)
|> Vl.encode_field(:latitude, "latitude", type: :quantitative)
|> Vl.encode(:size, value: 10)
|> Vl.config(view: [stroke: nil])
```

<!-- livebook:{"branch_parent_index":0} -->

## Day 3

Julenissessen har digitalisert julegaveprosessen. Julenissen har nå en lang digital liste over alle barn, med én bokstav per barn. J representerer et snilt barn, og N representerer et slemt barn. Som vil alle vet, er det kun snille barn som får gaver.

Lista har samme rekkefølge som ruta til julenissen, så nabobokstaver representerer barn som er fysiske naboer og tilhører sammen et nabolag.

Et nabolag som har akkurat like mange snille som slemme barn, er det julenissen kaller et "nøytralt nabolag". Slike nabolag er ekstremt viktig å monitorere og passe på, da det fort kan tippe over og bli et "slemt nabolag".
Oppgave

Julenissen ønsker å vite hvor stort det største nøytrale nabolaget er. Han ønsker også å vite hvor dette området ligger, indeksen i lista. Hvis det er flere nabolag som er like store som det største, skal det første nabolaget, nabolaget med lavest indeks returneres.

Løsningen er på formen "størrelse nabolag, indeks nabolag".

```elixir
day_3_input =
  "https://julekalender-backend.knowit.no/rails/active_storage/blobs/redirect/eyJfcmFpbHMiOnsibWVzc2FnZSI6IkJBaHBOdz09IiwiZXhwIjpudWxsLCJwdXIiOiJibG9iX2lkIn19--31fa0c541c69eeb9063ccfc56e686f4768662004/input.txt?disposition=inline"
  |> Util.Http.get_text()
```

```elixir
defmodule Neighborhood do
  def solve(input) do
    input
    |> String.graphemes()
    |> Stream.map(fn
      "J" -> 1
      "N" -> -1
    end)
    |> Stream.scan(&(&1 + &2))
    |> Stream.with_index()
    |> Enum.group_by(fn {n, _} -> n end, fn {_, li} -> li end)
    |> Map.values()
    |> Stream.filter(fn li -> length(li) > 1 end)
    |> Stream.map(fn li -> {List.last(li, 1) - List.first(li), List.first(li) + 1} end)
    |> Enum.max_by(fn {diff, first} -> {diff, -first} end)
  end
end
```

```elixir
defmodule Neighborhood.Test do
  use ExUnit.Case

  import Neighborhood

  test "example" do
    input = "JJJJJNNJJNNJJJJJ"

    assert solve(input) == {8, 3}
  end
end

%{failures: 0} = ExUnit.run()
```

```elixir
Neighborhood.solve(day_3_input)
```

<!-- livebook:{"branch_parent_index":0} -->

## Day 4

Piratsneglen Sneglulf er ute på tokt for å finne den sunkne byen Sneglantis. Han fant et gammelt manuskript som forklarte hvilket mønster han må seile i for å kunne finne den sagnomsuste byen i stillehavets uendelige rutenett:

```
Start på x:0, y:0
Seil nord (mot høyere y) til du kommer til en rad med nummer som er delelig på 3, men ikke 5; deretter snu øst
Seil øst (mot høyere x) til du kommer til en kolonne med nummer som er delelig på 5, men ikke 3; deretter snu nord
```

Etter å ha seilt 100 000 000 000 000 000 079 steg har Sneglulf fortsatt ikke funnet Sneglantis. Men hvor er han? Oppgi svar som x,y.

```elixir
defmodule NaiveSnailor do
  def travel({x, y}, _, 0), do: {x, y}

  def travel({x, y}, :north, remaining_steps) when rem(y, 3) == 0 and rem(y, 5) != 0,
    do: travel({x + 1, y}, :east, remaining_steps - 1)

  def travel({x, y}, :north, remaining_steps),
    do: travel({x, y + 1}, :north, remaining_steps - 1)

  def travel({x, y}, :east, remaining_steps) when rem(x, 5) == 0 and rem(x, 3) != 0,
    do: travel({x, y + 1}, :north, remaining_steps - 1)

  def travel({x, y}, :east, remaining_steps),
    do: travel({x + 1, y}, :east, remaining_steps - 1)
end
```

```elixir
defmodule Snailor.Test do
  use ExUnit.Case

  import NaiveSnailor

  test "example" do
    assert travel({0, 0}, :north, 11) == {5, 6}
  end
end

ExUnit.run()
```

```elixir
defmodule SmartSnailor do
  def travel({0, 0}, :north, n) do
    nn = div(n, 45)
    rr = rem(n, 45)

    if nn == 0 do
      NaiveSnailor.travel({0, 0}, :north, n)
    else
      NaiveSnailor.travel({nn * 30 - 3, 3 + nn * 15}, :north, rr)
    end
  end
end
```

```elixir
defmodule SmartSnailor.Test do
  use ExUnit.Case

  test "fixed values" do
    for n <- [0, 1, 2, 5, 10, 28, 103, 101, 1234] do
      assert SmartSnailor.travel({0, 0}, :north, n) == NaiveSnailor.travel({0, 0}, :north, n)
    end
  end

  test "random values" do
    for _ <- 1..1000 do
      n = Enum.random(1..100_000)
      assert SmartSnailor.travel({0, 0}, :north, n) == NaiveSnailor.travel({0, 0}, :north, n)
    end
  end
end

ExUnit.run()
```

```elixir
n = 100_000_000_000_000_000_079

SmartSnailor.travel({0, 0}, :north, n)
```

<!-- livebook:{"branch_parent_index":0} -->

## Day 5

Alven Aurora er interessert i å finne ut hvor mange generasjoner med alver hun kommer fra. Hun har laget et slektstre til å hjelpe med dette. Det er bare ett problem, hun har funnet ut at noen av alvene i treet var noen skikkelige Grincher og vil derfor ikke telle disse.

Denne fila inneholder et slektstree. Dersom man ignorerer alle Grinchene men likevell teller alle forfedre av disse, hvor lang tilbake går treet?

```elixir
day_5_input =
  Util.Http.get_text(
    "https://julekalender-backend.knowit.no/rails/active_storage/blobs/redirect/eyJfcmFpbHMiOnsibWVzc2FnZSI6IkJBaHBBak1DIiwiZXhwIjpudWxsLCJwdXIiOiJibG9iX2lkIn19--d6d3984e0f603df1771ef6b699e6e86d6ee577a7/tree.txt?disposition=inline"
  )
```

```elixir
defmodule ElfParser do
  import NimbleParsec

  def parse(input) do
    case elf(input) do
      {:ok, [treeish], "", _, _, _} ->
        treeish

      _ ->
        :error
    end
  end

  name = utf8_string([?A..?ø, ?a..?ø, ?-], min: 1)
  elf = choice([parsec(:elf), tag(name, :elf)])

  opening_parens = utf8_char('(')
  closing_parens = utf8_char(')')
  delimiter = utf8_char(' ')

  parents =
    ignore(opening_parens)
    |> repeat(
      lookahead_not(closing_parens)
      |> concat(elf)
      |> ignore(delimiter)
      |> concat(elf)
      |> ignore(closing_parens)
    )

  defparsec(:elf, tag(name |> concat(tag(parents, :parents)), :elf))
end

defmodule FamilyTreeNode do
  defstruct [:name, parents: []]

  defp parser_output_to_binary_tree({:elf, [name]}) when is_binary(name) do
    %FamilyTreeNode{name: name, parents: []}
  end

  defp parser_output_to_binary_tree({:elf, [name, {:parents, [p1, p2]}]}) when is_binary(name) do
    %FamilyTreeNode{
      name: name,
      parents: [parser_output_to_binary_tree(p1), parser_output_to_binary_tree(p2)]
    }
  end

  defp traverse(%FamilyTreeNode{name: name, parents: []}, acc), do: [acc ++ [name]]

  defp traverse(%FamilyTreeNode{name: name, parents: [p1, p2]}, acc) do
    traverse(p1, acc ++ [name]) ++ traverse(p2, acc ++ [name])
  end

  def solve(input) do
    (ElfParser.parse(input)
     |> parser_output_to_binary_tree
     |> traverse([])
     |> Enum.map(fn li -> li |> Enum.filter(fn name -> name != "Grinch" end) end)
     |> Enum.map(&length/1)
     |> Enum.max()) - 1
  end
end
```

```elixir
defmodule FamilyTreeNode.Test do
  use ExUnit.Case

  import FamilyTreeNode

  test "example" do
    input =
      "Aurora(Toralv(Grinch(Kari Robinalv) Alvborg) Grinch(Alva(Alve-Berit Anna) Grete(Ola Hans)))"

    assert solve(input) == 2
  end
end

ExUnit.run()
```

```elixir
day_5_input |> FamilyTreeNode.solve()
```
